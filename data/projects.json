[
  {
    "id": "sparrow-vps",
    "title": "sparrow-vps",
    "description": "wannabe vercel-like vps but defo not as complex",
    "topics": [],
    "languages": [
      "Vue",
      "TypeScript",
      "Go",
      "Python",
      "Shell",
      "Dockerfile",
      "HTML",
      "CSS"
    ],
    "readme": "# Sparrow VPS\nSparrow VPS is a simplified Virtual Private Server (VPS) system designed to streamline the deployment process for web applications directly from GitHub repositories. This platform automates the containerization and deployment workflow, making it easy for developers to get their projects up and running.\n\n## Architecture\nThe system is built on a microservices architecture, with distinct services for handling authentication, repository management, containerization, and deployment. These services work together to provide a seamless user experience.  \n![Archictecture Diagram](https://raw.githubusercontent.com/r3dacted42/sparrow-vps/refs/heads/main/sparrow_vps_arch.png)\n\n## Core Components:\n- Frontend: A Vue.js single-page application that provides the user interface for managing projects.\n- OAuth Service: Handles user authentication via GitHub OAuth and manages user data.\n- Repo Service: Clones and analyzes GitHub repositories to detect the project stack.\n- Containerization Service: Builds Docker images from the repository code and pushes them to a container registry.\n- Deployment Service: Deploys the containerized application to a Kubernetes cluster.\n- Monitoring Service: Tracks the health and resource usage of deployed applications using Prometheus and Grafana.\n\n## Features\n- GitHub Integration: Log in with your GitHub account to access and deploy your repositories.\n- Automated Dockerfile Generation: The system automatically generates a Dockerfile based on the detected project stack (e.g., JavaScript/Node.js, Python).\n- Kubernetes Deployment: Applications are deployed as pods within a Kubernetes cluster, ensuring scalability and resilience.\n- CI/CD Pipeline: Includes a Jenkinsfile for continuous integration and deployment, automating the build and push process for all microservices.\n- Live Previews: Preview the generated Dockerfile before building the image.\n- Project Dashboard: View and manage your deployed projects from a central dashboard.\n\n## Getting Started\nTo get the project running locally, you'll need to have Minikube and Docker installed.\n- Start Minikube:  \n  ```bash\n  minikube start\n  ```\n- Clone the repository:  \n  ```bash\n  git clone https://github.com/r3dacted42/sparrow-vps.git\n  cd sparrow-vps\n  ```\n- Run the deployment script:  \n  This script will set up the necessary Kubernetes resources and configure your local environment.\n  ```bash\n  ./start_services.sh\n  ```\n- Access the application:  \n  Once the services are running, you can access the frontend at `http://sparrow-vps.local`.\n\n## Usage\n- Login: Open your browser and navigate to the application URL. Log in using your GitHub account.\n- Add a Project: Click on \"Add Project\" and provide the URL of the GitHub repository you want to deploy.\n- Configure Workflow: Select the appropriate workflow for your project (e.g., JavaScript) and fill in the required details like build commands and environment variables.\n- Build and Deploy: The system will clone the repository, build a Docker image, and deploy it.\n- View Your Project: Once deployed, you can view your running application and manage it from the projects dashboard.\n\n## Screenshots\nTODO\n",
    "windowStyle": {
      "fgColor": "black-255",
      "bgColor": "yellow-168"
    }
  },
  {
    "id": "maxwell",
    "title": "maxwell appreciation page",
    "description": "dingus/maxwell appreciation page",
    "topics": [
      "dingus",
      "gmod",
      "maxwell",
      "meme"
    ],
    "languages": [
      "JavaScript",
      "HTML",
      "CSS"
    ],
    "homepage": "https://r3dacted42.github.io/maxwell/",
    "readme": "# Maxwell the Cat (dingus)  \n\n![badge](https://github.com/r3dacted42/maxwell/workflows/CI/CD/badge.svg)  \n[deployment](https://r3dacted42.github.io/maxwell/)  \nappreciation page for maxwell the cat, aka dingus.  \n\ndingus model: [bean (steam)](https://steamcommunity.com/sharedfiles/filedetails/?id=2874462324) | [bean (sketchfab)](https://sketchfab.com/3d-models/maxwell-the-cat-dingus-2ca7f3c1957847d6a145fc35de9046b0)  \ngm_construct background: [Alexander (steam)](https://steamcommunity.com/sharedfiles/filedetails/?id=2475844874)  \noriginal meme music: [Mr. Weebl (youtube)](https://youtu.be/3W-EkANZX8g)  \ngithub icon: [iconmonstr (website)](https://iconmonstr.com/github-3-svg/)\n\n![preview](https://raw.githubusercontent.com/r3dacted42/maxwell/refs/heads/master/public/dingus.webp)\n\nall credits go to respective owners.",
    "windowStyle": {
      "bgColor": "orange-168"
    }
  },
  {
    "id": "tic-tac-toe",
    "title": "tic-tac-toe",
    "description": "multiplayer tic-tac-toe game using phaser and pusher",
    "topics": [
      "multiplayer-game",
      "online-game",
      "phaser3",
      "phaserjs",
      "tic-tac-toe",
      "tictactoe",
      "two-player"
    ],
    "languages": [
      "JavaScript",
      "HTML",
      "CSS"
    ],
    "homepage": "https://tic-tac-toe-chi-liart.vercel.app",
    "readme": "# tic-tac-toe\ntic-tac-toe game using phaser and pusher\n\n## architecture\n- backend runs on express\n- pusher used by server for matchmaking and clients for intercommunication\n- clients make rest calls to server for game events\n- server maintains the game state and verifies moves before modifying the state\n\n## flow\n- pusher authentication and room assignment\n    - client sends user's chosen name to authentication endpoint\n    - server returns the assigned user-id and room-id for the client\n    - server also sends the user-id, and user-info (name, room-id) of the new user to pusher\n    - server stores the newly created room's status as waiting, with a member count of 0\n    - client joins the lobby channel and subscribes to the count change event to keep track of the number of users waiting to play\n    - on success, the client loads the `Lobby` scene and presents the room-id, a text box to enter an existing room-id, and a button to join a random existing room\n- pusher authorization and room joining\n    - client sends the user-id and room-id (which when prefixed with 'presence-' becomes the channel name) to the authorization endpoint\n    - server verifies if the room exists and is valid, and then queries pusher to get the number of users in that room\n    - if the number of users is less than 2, the user is provided entry into the room and the room is marked as ready when the user-count reaches 2\n    - when the room is ready, the server stores the user-id of the player who will make the first move, the first move type (X), the scores (0, 0), and the board state (empty)\n    - if a user tries to join a room that already has 2 players, they are notified that the room is full\n    - when the room is ready (2 users have joined), the client leaves the lobby channel and loads the `Play` scene\n    - when the endpoint for joining a random room is called, the server finds the first room that has 1 user and returns the room id. if no such rooms exist, the user's room is marked as random and a searching message is displayed\n    - the users are also able to communicate through text messages that can be sent through a text box at the bottom left\n- game initiation\n    - clients query the server at the room-status endpoint to receive the initial state of the game\n    - clients set up the board and the player who's marked as the first player is displayed the possible moves they can make (a bunch of X's accross the board)\n- game flow\n    - on selection of a move by the user, it is sent to the server at the make-move endpoint and is verified to be valid\n    - on validation, the client receives the updated state of the game and sends the result to the other user in the room through pusher\n    - both clients update the views and the next user is displayed the possible moves\n    - this goes on until there's a winner or a tie, with the server validating each step and deciding the outcome\n    - when the match ends, the result is displayed on the clients and a timer of 10 seconds is started\n- game reset\n    - when the timer ends, both the clients make a request to the reset-game endpoint\n    - client whose request reaches first is responded that the reset has been initiated\n    - the server sets the room status as resetting and resets the game state, with the losing player getting the first move\n    - on arrival of the second client's request, the room is marked as ready and the new state of the game is sent back\n    - client who received the state then forwards it to the other client in the room and both reset the board\n    - the game begins again with the losing user's client displaying the possible moves\n    - this keeps on going until the users reload the page\n    - if a user leaves mid-match, the user who is still in the room is notified and the page reloads in 10 seconds (not implemented yet)\n\n## api endpoints\n- /api/auth (pusher authentication)\n- /api/auth-chan (pusher authorization)\n- /api/room-status\n- /api/join-random\n- /api/make-move\n- /api/reset-game\n\n## thanks\nphaser, pusher, vercel, the community  \npeace â® \n",
    "windowStyle": {
      "bgColor": "black-168"
    }
  },
  {
    "id": "turtle-graphics",
    "title": "webgl turtle graphics",
    "description": "computer graphics programming assignment 1",
    "topics": [],
    "languages": [
      "JavaScript",
      "CSS",
      "HTML"
    ],
    "homepage": "https://r3dacted42.github.io/turtle-graphics/",
    "readme": "# turtle graphics\n\n![ci/cd badge](https://github.com/r3dacted42/turtle-graphics/workflows/CI/CD/badge.svg)  \n[deployment](https://r3dacted42.github.io/turtle-graphics/)\n\n## how to run\n- `git clone https://github.com/r3dacted42/turtle-graphics.git`\n- `cd turtle-graphics`\n- `npm install`\n- `npm run dev`\n- open the url displayed in the terminal\n",
    "windowStyle": {
      "bgColor": "green-168"
    }
  },
  {
    "id": "bank-mgmt-sys",
    "title": "ncurses bank mgmt sys",
    "description": "bank management server-client system mini project made for software systems course",
    "topics": [
      "concurrent-server",
      "file-locking",
      "multithreading",
      "ncurses-tui",
      "socket-programming"
    ],
    "languages": [
      "C",
      "Shell"
    ],
    "readme": "# swsys pre-midterm \"mini\" project\n\"bank management system\"  \nuse `./install_packages.sh` to install required C libraries  \nuse `./run_server.sh` and `./run_client.sh` to run server and client respectively  \nuses libbcrypt for password hashing and ncurses for client tui  \nplease find the up-to-date project repository here: [r3dacted42/bank-mgmt-sys](https://github.com/r3dacted42/bank-mgmt-sys)  \n\n## feature set\nthe following user phases are supported:  \n- admin\n    - create user\n    - view / modify user\n    - delete user\n- manager\n    - activate / deactivate customer accounts\n    - assign loan applications to employees\n    - review customer feedback\n- employee\n    - add new customer\n    - modify customer info (needs fixing)\n    - review assigned loan applications\n    - view customer transactions\n- customer\n    - view balance\n    - deposit money\n    - withdraw money\n    - transfer money\n    - apply for loan\n    - view submitted loan applications\n    - view transaction history\n    - add feedback  \n\naside from the above, all users can their change password as well\n\n## todo\n- delete all user related records on user deletion\n- delete all irrelevant records on user role change\n- add docstrings for important functions xP\n\n## known issues\n- updating customer info from employee phase causes crash\n\n## general flow\n- the models store the structure of data used throughout the project\n- the controllers directly interact with the database files, using locking to ensure the files are not modified unexpectedly\n- the server births a new thread for each incoming connection\n- the client must login using credentials which are verified by the worker thread using functions provided by \nthe [user controller](https://github.com/r3dacted42/bank-mgmt-sys/blob/master/controller/user.h)\n- if the same user logs in from a different terminal, the previous thread with for that user account is cancelled\n- once authenticated, the server responds with the role of the user\n- the client shows the menu corresponding to the role of the logged-in user\n- subsequent requests are serviced as they arrive and the response is sent by the worker thread through the socket\n- for special kinds of request where the size of the response is not pre-known, the data is buffered into the socket \nthe number of objects to be read from the socket is sent in the response under the `bufcount` variable\n- the types of requests and their required data can be seen in [request.h](https://github.com/r3dacted42/bank-mgmt-sys/blob/master/model/request.h)\n- unions are used in the Request and Response structs to store the required data before being sent\n\n## class diagram\n![class_diagram.png](https://github.com/r3dacted42/bank-mgmt-sys/blob/master/class_diagram.png?raw=true)\n"
  }
]